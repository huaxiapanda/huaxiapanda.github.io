<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>elasticsearch入门_01</title>
      <link href="/2019/10/15/elasticsearch%E5%85%A5%E9%97%A8_01/"/>
      <url>/2019/10/15/elasticsearch%E5%85%A5%E9%97%A8_01/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-Elasticsearch聚合分析"><a href="#1-Elasticsearch聚合分析" class="headerlink" title="1 Elasticsearch聚合分析"></a>1 Elasticsearch聚合分析</h1><h2 id="1-1-需求1-计算每个tag下的商品数量"><a href="#1-1-需求1-计算每个tag下的商品数量" class="headerlink" title="1.1 需求1_计算每个tag下的商品数量"></a>1.1 需求1_计算每个tag下的商品数量</h2><p>案例:进行聚合分析需要fielddata属性设置为true</p><pre><code class="bash">{  &quot;properties&quot;: {    &quot;tags&quot;:{      &quot;type&quot;:&quot;text&quot;,      &quot;fielddata&quot;: true    }  }}</code></pre><pre><code class="bash">GET /ecommerce/product/_search{  &quot;size&quot;: 0,  &quot;aggs&quot;: {    &quot;group_by_tags&quot;: {      &quot;terms&quot;: {        &quot;field&quot;: &quot;tags&quot;      }    }  }}</code></pre><h2 id="1-2-需求2-对名称中包含yagao的商品，计算每个tag下的商品数量"><a href="#1-2-需求2-对名称中包含yagao的商品，计算每个tag下的商品数量" class="headerlink" title="1.2 需求2_对名称中包含yagao的商品，计算每个tag下的商品数量"></a>1.2 需求2_对名称中包含yagao的商品，计算每个tag下的商品数量</h2><pre><code class="bash">GET /ecommerce/product/_search{  &quot;size&quot;: 0,  &quot;query&quot;: {    &quot;match&quot;: {      &quot;name&quot;: &quot;yagao&quot;    }  },  &quot;aggs&quot;: {    &quot;group_by_tags&quot;: {      &quot;terms&quot;: {        &quot;field&quot;: &quot;tags&quot;      }    }  }}</code></pre><h2 id="1-3-需求3-先分组，在计算每组的平均值，计算每个tag下的商品的平均价格"><a href="#1-3-需求3-先分组，在计算每组的平均值，计算每个tag下的商品的平均价格" class="headerlink" title="1.3 需求3_先分组，在计算每组的平均值，计算每个tag下的商品的平均价格"></a>1.3 需求3_先分组，在计算每组的平均值，计算每个tag下的商品的平均价格</h2><pre><code class="bash">GET /ecommerce/product/_search{  &quot;size&quot;: 0,  &quot;aggs&quot;: {    &quot;group_by_tags&quot;: {      &quot;terms&quot;: {        &quot;field&quot;: &quot;tags&quot;      },      &quot;aggs&quot;: {        &quot;avg_price&quot;: {          &quot;avg&quot;: {            &quot;field&quot;: &quot;price&quot;          }        }      }    }  }}</code></pre><h2 id="1-4-需求4-计算每个tag下的商品的平均价格，并且按照平均价格降序排序"><a href="#1-4-需求4-计算每个tag下的商品的平均价格，并且按照平均价格降序排序" class="headerlink" title="1.4 需求4_计算每个tag下的商品的平均价格，并且按照平均价格降序排序"></a>1.4 需求4_计算每个tag下的商品的平均价格，并且按照平均价格降序排序</h2><pre><code class="bash">GET /ecommerce/product/_search{  &quot;size&quot;: 0,  &quot;aggs&quot;: {    &quot;group_by_tags&quot;: {      &quot;terms&quot;: {        &quot;field&quot;: &quot;tags&quot;,        &quot;order&quot;: {          &quot;avg_price&quot;: &quot;desc&quot;        }      },      &quot;aggs&quot;: {        &quot;avg_price&quot;: {          &quot;avg&quot;: {            &quot;field&quot;: &quot;price&quot;          }        }      }    }  }}</code></pre><h2 id="1-5-需求5-按照指定的价格范围区间进行分组，然后在每组内按照tag进行分组，最后在计算每组的平均价格"><a href="#1-5-需求5-按照指定的价格范围区间进行分组，然后在每组内按照tag进行分组，最后在计算每组的平均价格" class="headerlink" title="1.5 需求5_按照指定的价格范围区间进行分组，然后在每组内按照tag进行分组，最后在计算每组的平均价格"></a>1.5 需求5_按照指定的价格范围区间进行分组，然后在每组内按照tag进行分组，最后在计算每组的平均价格</h2><pre><code class="bash">GET /ecommerce/product/_search{  &quot;size&quot;: 0,  &quot;aggs&quot;: {    &quot;group_by_price&quot;: {      &quot;range&quot;: {        &quot;field&quot;: &quot;price&quot;,        &quot;ranges&quot;: [          {            &quot;from&quot;: 0,            &quot;to&quot;: 20          },          {            &quot;from&quot;: 20            , &quot;to&quot;: 40          },          {            &quot;from&quot;: 40,            &quot;to&quot;: 50          }        ]      },      &quot;aggs&quot;: {        &quot;group_by_tags&quot;: {          &quot;terms&quot;: {            &quot;field&quot;: &quot;tags&quot;          },          &quot;aggs&quot;: {            &quot;avg_price&quot;: {              &quot;avg&quot;: {                &quot;field&quot;: &quot;price&quot;              }            }          }        }      }    }  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> es </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch入门</title>
      <link href="/2019/10/14/elasticsearch%E5%85%A5%E9%97%A8/"/>
      <url>/2019/10/14/elasticsearch%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-elasticsearch核心概念"><a href="#1-elasticsearch核心概念" class="headerlink" title="1. elasticsearch核心概念"></a>1. elasticsearch核心概念</h1><p><a href="https://www.elastic.co/cn/downloads/past-releases" target="_blank" rel="noopener">elk下载地址</a></p><h2 id="1-1-Near-Realtime-NRT"><a href="#1-1-Near-Realtime-NRT" class="headerlink" title="1.1 Near Realtime(NRT)"></a>1.1 Near Realtime(NRT)</h2><p>&emsp;&emsp;近实时，两个意思，从写入数据到数据可以被搜索到有一个小延迟（大概1秒）；基于es执行搜索和分析可以达到秒级.</p><h2 id="1-2-Cluster"><a href="#1-2-Cluster" class="headerlink" title="1.2 Cluster"></a>1.2 Cluster</h2><p>&emsp;&emsp;集群，包含多个节点，每个节点属于哪个集群是通过一个配置（集群名称，默认是elasticsearch）来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常.<strong>可以在elasticsearch.yml中修改这个名称</strong></p><h2 id="1-3-Node"><a href="#1-3-Node" class="headerlink" title="1.3 Node"></a>1.3 Node</h2><p>&emsp;&emsp;节点，集群中的一个节点，节点也有一个名称（默认是随机分配的），节点名称很重要（在执行运维管理操作的时候），默认节点会去加入一个名称为”elasticsearch”的集群，如果直接启动一堆节点，那么它们会自动组成一个elasticsearch集群，当然一个节点也可以组成一个elasticsearch集群.</p><h2 id="1-4-Document-amp-field"><a href="#1-4-Document-amp-field" class="headerlink" title="1.4 Document&amp;field"></a>1.4 Document&amp;field</h2><p>&emsp;&emsp;文档，es中的最小数据单元，一个document可以是一条客户数据，一条商品分类数据，一条订单数据，通常用JSON数据结构表示，每个index下的type中，都可以去存储多个document。一个document里面有多个field，每个field就是一个数据字段。<br><br>例如一个product document</p><pre><code class="javascript">// product document{    &quot;product_id&quot;:&quot;3&quot;,    &quot;product_name&quot;:&quot;华为荣耀P30 Pro&quot;,    &quot;product_desc&quot;:&quot;50倍放大，清晰&quot;,    &quot;category_id&quot;:&quot;2&quot;,    &quot;category_name&quot;:&quot;手机数码&quot;}</code></pre><p><strong>注：index其实就是一个数据库，可以存储很多type，type其实就是一张表,可以存储很多Document，Document其实就是一行数据,一行数据有很多Filed，Filed其实就是一行中的一个字段。</strong></p><h2 id="1-5-Index"><a href="#1-5-Index" class="headerlink" title="1.5 Index"></a>1.5 Index</h2><p>&emsp;&emsp;索引，包含一堆有相似结构的文档数据，比如可以有一个客户索引，商品分类索引，订单索引，索引有一个名称。一个index包含很多document，一个index就代表了一类类似的或者相同的document。比如说建立一个product index，商品索引，里面可能就存放了所有的商品数据，所有的商品document。</p><h2 id="1-6-Type"><a href="#1-6-Type" class="headerlink" title="1.6 Type"></a>1.6 Type</h2><p>&emsp;&emsp; 类型，每个索引里都可以有一个或多个type，type是index中的一个逻辑数据分类，一个type下的document，都有相同的field，比如博客系统，有一个索引，可以定义用户数据type，博客数据type，评论数据type。<br><br>&emsp;&emsp;商品index，里面存放了所有的商品数据，商品document,但是商品分很多种类，每个种类的document的field可能不太一样，比如说电器商品，可能还包含一些诸如售后时间范围这样的特殊field；生鲜商品，还包含一些诸如生鲜保质期之类的特殊field <br></p><p>example:<br><br>&emsp;&emsp;type,日化商品type，电器商品type，生鲜商品type<br><br>&emsp;&emsp;日化商品type：product_id，product_name，product_desc，category_id，category_name<br><br>&emsp;&emsp;电器商品type：product_id，product_name，product_desc，category_id，category_name，service_period<br><br>&emsp;&emsp;生鲜商品type：product_id，product_name，product_desc，category_id，category_name，eat_period<br></p><p>&emsp;&emsp;每一个type里面，都会包含一堆document</p><pre><code class="javascript">{  &quot;product_id&quot;: &quot;2&quot;,  &quot;product_name&quot;: &quot;长虹电视机&quot;,  &quot;product_desc&quot;: &quot;4k高清&quot;,  &quot;category_id&quot;: &quot;3&quot;,  &quot;category_name&quot;: &quot;电器&quot;,  &quot;service_period&quot;: &quot;1年&quot;}{  &quot;product_id&quot;: &quot;3&quot;,  &quot;product_name&quot;: &quot;基围虾&quot;,  &quot;product_desc&quot;: &quot;纯天然，冰岛产&quot;,  &quot;category_id&quot;: &quot;4&quot;,  &quot;category_name&quot;: &quot;生鲜&quot;,  &quot;eat_period&quot;: &quot;7天&quot;}</code></pre><h2 id="1-7-shard"><a href="#1-7-shard" class="headerlink" title="1.7 shard"></a>1.7 shard</h2><p>&emsp;&emsp;单台机器无法存储大量数据，es可以将一个索引中的数据切分为多个shard，分布在多台服务器上存储。有了shard就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个shard都是一个lucene index。</p><h2 id="1-8-replica"><a href="#1-8-replica" class="headerlink" title="1.8 replica"></a>1.8 replica</h2><p>&emsp;&emsp;任何一个服务器随时可能故障或宕机，此时shard可能就会丢失，因此可以为每个shard创建多个replica副本。replica可以在shard故障时提供备用服务，保证数据不丢失，多个replica还可以提升搜索操作的吞吐量和性能。primary shard（建立索引时一次设置，不能修改，默认5个），replica shard（随时修改数量，默认1个），默认每个索引10个shard，5个primary shard，5个replica shard，最小的高可用配置，是2台服务器。</p><h2 id="1-9-share和replica图解"><a href="#1-9-share和replica图解" class="headerlink" title="1.9 share和replica图解"></a>1.9 share和replica图解</h2><p><img src="//huaxiapanda.github.io/2019/10/14/elasticsearch入门/1.png" alt="shared和replica图解"></p><h2 id="1-10-elasticsearch核心概念-vs-数据库核心概念"><a href="#1-10-elasticsearch核心概念-vs-数据库核心概念" class="headerlink" title="1.10 elasticsearch核心概念 vs 数据库核心概念"></a>1.10 elasticsearch核心概念 vs 数据库核心概念</h2><table><thead><tr><th align="center">Elasticsearch</th><th align="center">数据库</th></tr></thead><tbody><tr><td align="center">Document</td><td align="center">行/row</td></tr><tr><td align="center">Type</td><td align="center">表/table</td></tr><tr><td align="center">Index</td><td align="center">库/database</td></tr></tbody></table><h1 id="2-基础API"><a href="#2-基础API" class="headerlink" title="2 基础API"></a>2 基础API</h1><h2 id="2-1-Elasticsearch之document数据格式"><a href="#2-1-Elasticsearch之document数据格式" class="headerlink" title="2.1 Elasticsearch之document数据格式"></a>2.1 Elasticsearch之document数据格式</h2><p>&emsp;&emsp;elasticsearch是面向文档的搜索分析引擎<br></p><ul><li>应用系统的数据结构都是面向对象的，复杂的</li><li>对象数据存储到数据库中，只能拆解开来，变为扁平的多张表，每次查询的时候还得还原回对象格式，相当麻烦</li><li>ES是面向文档的，文档中存储的数据结构，与面向对象的数据结构是一样的，基于这种文档数据结构，es可以提供复杂的索引，全文检索，分析聚合等功能.</li><li>es的document用json数据格式来表达<br></li></ul><p><strong>传统的关系型数据库的数据格式:</strong></p><pre><code class="Java">public class Employee {  private String email;  private String firstName;  private String lastName;  private EmployeeInfo info;  private Date joinDate;}private class EmployeeInfo {  private String bio; // 性格  private Integer age;  private String[] interests; // 兴趣爱好}EmployeeInfo info = new EmployeeInfo();info.setBio(&quot;curious and modest&quot;);info.setAge(30);info.setInterests(new String[]{&quot;bike&quot;, &quot;climb&quot;});Employee employee = new Employee();employee.setEmail(&quot;zhangsan@sina.com&quot;);employee.setFirstName(&quot;san&quot;);employee.setLastName(&quot;zhang&quot;);employee.setInfo(info);employee.setJoinDate(new Date());// employee对象：里面包含了Employee类自己的属性，还有一个EmployeeInfo对象// 两张表：employee表，employee_info表，将employee对象的数据重新拆开来，变成Employee数据和EmployeeInfo数据// employee表：email，first_name，last_name，join_date，4个字段// employee_info表：bio，age，interests，3个字段；此外还有一个外键字段，比如employee_id，关联着employee表</code></pre><p><strong>elasticsearch数据格式为:</strong></p><pre><code class="javascript">{    &quot;email&quot;:      &quot;zhangsan@sina.com&quot;,    &quot;first_name&quot;: &quot;san&quot;,    &quot;last_name&quot;: &quot;zhang&quot;,    &quot;info&quot;: {        &quot;bio&quot;:         &quot;curious and modest&quot;,        &quot;age&quot;:         30,        &quot;interests&quot;: [ &quot;bike&quot;, &quot;climb&quot; ]    },    &quot;join_date&quot;: &quot;2017/01/01&quot;}</code></pre><h2 id="2-2-基础API"><a href="#2-2-基础API" class="headerlink" title="2.2 基础API"></a>2.2 基础API</h2><h3 id="2-2-1-快速查看集群的健康状态"><a href="#2-2-1-快速查看集群的健康状态" class="headerlink" title="2.2.1 快速查看集群的健康状态"></a>2.2.1 快速查看集群的健康状态</h3><p>es提供了一套api,叫做cat api,可以查看es中各种各样的数据:</p><pre><code class="bash">GET /_cat/health?v</code></pre><p><img src="//huaxiapanda.github.io/2019/10/14/elasticsearch入门/2.png" alt="健康状态结果"></p><ul><li><p><strong>如何快速了解集群的健康状态?green、yellow、red?</strong></p><ul><li>green:每个索引的primary shard和replica shard都是active状态的。</li><li>yellow:每个索引的primary shard都是active状态的，但是部分replica shard不是active状态，处于不可用的状态。</li><li>red:不是所有索引的primary shard都是active状态的，部分索引有数据丢失了。</li></ul></li><li><p><strong>为什么现在会处于一个yellow状态？<br></strong><br>&emsp;&emsp;我们现在就一个笔记本电脑，就启动了一个es进程，相当于就只有一个node。现在es中有一个index，就是kibana自己内置建立的index。由于默认的配置是给每个index分配5个primary shard和5个replica shard，而且primary shard和replica shard不能在同一台机器上（为了容错）。现在kibana自己建立的index是1个primary shard和1个replica shard。当前就一个node，所以只有1个primary shard被分配了和启动了，但是一个replica shard没有第二台机器去启动。</p><h3 id="2-2-2-快速查看集群中有哪些索引"><a href="#2-2-2-快速查看集群中有哪些索引" class="headerlink" title="2.2.2 快速查看集群中有哪些索引"></a>2.2.2 快速查看集群中有哪些索引</h3><pre><code class="bash">GET /_cat/indices?v</code></pre><p><img src="//huaxiapanda.github.io/2019/10/14/elasticsearch入门/3.png" alt="查看集群中的索引"></p><h2 id="2-3-简单的索引操作"><a href="#2-3-简单的索引操作" class="headerlink" title="2.3 简单的索引操作"></a>2.3 简单的索引操作</h2><h3 id="2-3-1-创建一个索引"><a href="#2-3-1-创建一个索引" class="headerlink" title="2.3.1 创建一个索引"></a>2.3.1 创建一个索引</h3><pre><code class="bash"># 创建一个新的索引PUT /test_index?pretty</code></pre><p><img src="//huaxiapanda.github.io/2019/10/14/elasticsearch入门/4.png" alt="创建索引"></p><h3 id="2-3-2-删除一个索引"><a href="#2-3-2-删除一个索引" class="headerlink" title="2.3.2 删除一个索引"></a>2.3.2 删除一个索引</h3><pre><code class="bash"># 删除一个索引DELETE /test_index?pretty</code></pre><p><img src="//huaxiapanda.github.io/2019/10/14/elasticsearch入门/5.png" alt="删除索引"></p><h2 id="2-4-ES之增删改查-CRUD-操作API"><a href="#2-4-ES之增删改查-CRUD-操作API" class="headerlink" title="2.4 ES之增删改查(CRUD)操作API"></a>2.4 ES之增删改查(CRUD)操作API</h2><p>&emsp;&emsp;es的增删改查操作使用商品的增删改查为例子</p><h3 id="2-4-1-新增商品"><a href="#2-4-1-新增商品" class="headerlink" title="2.4.1 新增商品"></a>2.4.1 新增商品</h3><p>语法:<br></p><pre><code class="bash"># 向es中插入一行记录PUT /index/type/id{&quot;json数据&quot;}</code></pre><p>案例:<br></p><pre><code class="bash">PUT /ecommerce/product/1{&quot;name&quot;:&quot;gaolujie yagao&quot;,&quot;desc&quot;:&quot;gaoxiao meibai&quot;,&quot;price&quot;:25,&quot;producer&quot;:&quot;gaolujie producer&quot;,&quot;tags&quot;:[&quot;meibai&quot;,&quot;fangzhu&quot;]}PUT /ecommerce/product/2{  &quot;name&quot;:&quot;jiajieshi yagao&quot;,  &quot;desc&quot;:&quot;youxiao fangzhu&quot;,  &quot;price&quot;:25,  &quot;producer&quot;:&quot;jiajieshi producer&quot;,   &quot;tags&quot;:[&quot;fangzhu&quot;]}PUT /ecommerce/product/3{  &quot;name&quot;:&quot;zhonghua yagao&quot;,  &quot;desc&quot;:&quot;caoben zhiwu&quot;,  &quot;price&quot;:40,  &quot;producer&quot;:&quot;zhonghua producer&quot;,   &quot;tags&quot;:[&quot;qingxin&quot;]}</code></pre><p><img src="//huaxiapanda.github.io/2019/10/14/elasticsearch入门/6.png" alt="插入一行记录"><br></p></li><li><p>index 插入es的库名称</p></li><li><p>type: 插入es的表名称</p></li><li><p>id: 插入es的行标识</p></li><li><p>version: 插入es的数据版本</p></li><li><p>result: 插入es的结果,created 代表新增</p></li><li><p>shards: 插入es的一些shards信息</p><ul><li>total: 总共两个shard</li><li>successful: 成功1个,因为只启动了一个节点,目前只有一个primary shard,没有replica shard</li><li>failed: 失败0个</li></ul></li><li><p>created: 新增结果,true代表成功,false代表失败<br></p></li></ul><h3 id="2-4-2-查询商品文档"><a href="#2-4-2-查询商品文档" class="headerlink" title="2.4.2 查询商品文档"></a>2.4.2 查询商品文档</h3><p>语法:<br></p><pre><code class="bash">//查询商品文档数据GET /index/type/id</code></pre><p>案例:<br></p><pre><code class="bash">GET /ecommerce/product/1</code></pre><p><img src="//huaxiapanda.github.io/2019/10/14/elasticsearch入门/7.png" alt="查询语法结果"><br></p><p>+index: 查询es的库名称<br>+type: 查询es的表名称<br>+id: 查询es的行标识<br>+version: 查询es的数据版本</p><ul><li>found: 是否查询到记录,true是查询到记录,false是没有查询到记录.</li><li>source: 查询到的该条记录的内容<br></li></ul><h3 id="2-4-3-修改记录-替换文档"><a href="#2-4-3-修改记录-替换文档" class="headerlink" title="2.4.3 修改记录_替换文档"></a>2.4.3 修改记录_替换文档</h3><p>案例:<br></p><pre><code class="bash">PUT /ecommerce/product/1{    &quot;name&quot;:&quot;jiaqiangban gaolujie yaoga&quot;}</code></pre><p><img src="//huaxiapanda.github.io/2019/10/14/elasticsearch入门/8.png" alt="替换文档"><br></p><ul><li>index: 查询es的库名称</li><li>type: 查询es的表名称</li><li>id: 查询es的行标识</li><li>version: 查询es的数据版本</li><li>result: 结果是更新<br></li></ul><p><strong>替换方式有一个不好，即使必须带上所有的field,才能去进行信息的修改</strong></p><pre><code class="bash">GET /ecommerce/product/1</code></pre><p><img src="//huaxiapanda.github.io/2019/10/14/elasticsearch入门/9.png" alt="查询结果"><br>由上图可以看出,我们只修改了一个name字段,结果其他的字段都被覆盖掉了.但是这不是我们想要的结果.</p><h3 id="2-4-4-修改记录-更新文档"><a href="#2-4-4-修改记录-更新文档" class="headerlink" title="2.4.4 修改记录_更新文档"></a>2.4.4 修改记录_更新文档</h3><p>案例:<br></p><pre><code class="bash">PUT /ecommerce/product/1{    &quot;name&quot;:&quot;gaolujie yagao&quot;,    &quot;desc&quot;:&quot;gaoxiao meibai&quot;,    &quot;price&quot;:30,    &quot;producer&quot;:&quot;gaolujie producer&quot;,    &quot;tags&quot;:[&quot;meibai&quot;,&quot;fangzhu&quot;]}# 使用post进行文档的指定字段的更新POST /ecommerce/product/1/_update{  &quot;doc&quot;:{    &quot;name&quot;:&quot;jiaqiangban gaolujie yagao&quot;  }}</code></pre><p><img src="//huaxiapanda.github.io/2019/10/14/elasticsearch入门/10.png" alt="指定字段更新"></p><h3 id="2-4-5-删除文档"><a href="#2-4-5-删除文档" class="headerlink" title="2.4.5 删除文档"></a>2.4.5 删除文档</h3><pre><code class="bash"># 删除文档DELETE /ecommerce/product/1</code></pre><p><img src="//huaxiapanda.github.io/2019/10/14/elasticsearch入门/11.png" alt="删除结果"><br>再次执行删除操作出现如下结果:<br><img src="//huaxiapanda.github.io/2019/10/14/elasticsearch入门/12.png" alt="删除结果"><br>执行查询操作:<br><img src="//huaxiapanda.github.io/2019/10/14/elasticsearch入门/13.png" alt="查询结果"></p><h1 id="3-Elasticsearch查询方式"><a href="#3-Elasticsearch查询方式" class="headerlink" title="3 Elasticsearch查询方式"></a>3 Elasticsearch查询方式</h1><h2 id="3-1-query-string-search"><a href="#3-1-query-string-search" class="headerlink" title="3.1 query string search"></a>3.1 query string search</h2><p>使用查询字符串进行搜索所有的商品信息</p><pre><code class="bash">GET /ecommerce/product/_search</code></pre><p>查询结果如下所示:</p><pre><code class="javascript">{  &quot;took&quot;: 29,  &quot;timed_out&quot;: false,  &quot;_shards&quot;: {    &quot;total&quot;: 5,    &quot;successful&quot;: 5,    &quot;failed&quot;: 0  },  &quot;hits&quot;: {    &quot;total&quot;: 3,    &quot;max_score&quot;: 1,    &quot;hits&quot;: [      {        &quot;_index&quot;: &quot;ecommerce&quot;,        &quot;_type&quot;: &quot;product&quot;,        &quot;_id&quot;: &quot;2&quot;,        &quot;_score&quot;: 1,        &quot;_source&quot;: {          &quot;name&quot;: &quot;jiajieshi yagao&quot;,          &quot;desc&quot;: &quot;youxiao fangzhu&quot;,          &quot;price&quot;: 25,          &quot;producer&quot;: &quot;jiajieshi producer&quot;,          &quot;tags&quot;: [            &quot;fangzhu&quot;          ]        }      },      {        &quot;_index&quot;: &quot;ecommerce&quot;,        &quot;_type&quot;: &quot;product&quot;,        &quot;_id&quot;: &quot;1&quot;,        &quot;_score&quot;: 1,        &quot;_source&quot;: {          &quot;name&quot;: &quot;gaolujie yagao&quot;,          &quot;desc&quot;: &quot;gaoxiao meibai&quot;,          &quot;price&quot;: 30,          &quot;producer&quot;: &quot;gaolujie producer&quot;,          &quot;tags&quot;: [            &quot;meibai&quot;,            &quot;fangzhu&quot;          ]        }      },      {        &quot;_index&quot;: &quot;ecommerce&quot;,        &quot;_type&quot;: &quot;product&quot;,        &quot;_id&quot;: &quot;3&quot;,        &quot;_score&quot;: 1,        &quot;_source&quot;: {          &quot;name&quot;: &quot;zhonghua yagao&quot;,          &quot;desc&quot;: &quot;caoben zhiwu&quot;,          &quot;price&quot;: 40,          &quot;producer&quot;: &quot;zhonghua producer&quot;,          &quot;tags&quot;: [            &quot;qingxin&quot;          ]        }      }    ]  }}</code></pre><ul><li>took: 查询花费的时间(ms)</li><li>timed_out: 是否超时 false表示没有,true表示超时</li><li>shards: 查询的shard信息</li><li>hits: 查询命中信息<ul><li>total: 总共几条记录</li><li>max_score: 匹配分数</li><li>hits: 命中的所有记录<ul><li>index: 库</li><li>type: 表</li><li>id: 行</li><li>score: 匹配分数</li><li>source: 信息<br><br></li></ul></li></ul></li></ul><h2 id="3-2-Query-DSL"><a href="#3-2-Query-DSL" class="headerlink" title="3.2 Query DSL"></a>3.2 Query DSL</h2><p><strong>DSL:Domain Specified Language，特定领域的语言</strong><br><br>http request body：请求体，可以用json的格式来构建查询语法，比较方便，可以构建各种复杂的语法，比query string search肯定强大多了.</p><h3 id="3-2-1-查询所有的商品"><a href="#3-2-1-查询所有的商品" class="headerlink" title="3.2.1 查询所有的商品"></a>3.2.1 查询所有的商品</h3><pre><code class="bash">GET /ecommerce/product/_search{  &quot;query&quot;: {&quot;match_all&quot;: {}}}</code></pre><h3 id="3-2-2-按照指定条件查询"><a href="#3-2-2-按照指定条件查询" class="headerlink" title="3.2.2 按照指定条件查询"></a>3.2.2 按照指定条件查询</h3><p>案例:查询商品名称中包含yagao的商品,并且按照商品价格降序排序</p><pre><code class="bash">GET /ecommerce/product/_search{  &quot;query&quot;: {    &quot;match&quot;: {      &quot;name&quot;: &quot;yagao&quot;    }  },  &quot;sort&quot;: [    {      &quot;price&quot;: {        &quot;order&quot;: &quot;desc&quot;      }    }  ]}</code></pre><h3 id="3-2-3-分页查询"><a href="#3-2-3-分页查询" class="headerlink" title="3.2.3 分页查询"></a>3.2.3 分页查询</h3><pre><code class="bash">GET /ecommerce/product/_search{  &quot;query&quot;: {&quot;match_all&quot;: {}},  &quot;from&quot;: 0,  &quot;size&quot;: 2}</code></pre><h3 id="3-2-4-查询指定字段信息"><a href="#3-2-4-查询指定字段信息" class="headerlink" title="3.2.4 查询指定字段信息"></a>3.2.4 查询指定字段信息</h3><pre><code class="bash">GET /ecommerce/product/_search{  &quot;query&quot;: {&quot;match_all&quot;: {}},  &quot;_source&quot;: [&quot;name&quot;,&quot;price&quot;]}</code></pre><h3 id="3-2-5-高级查询"><a href="#3-2-5-高级查询" class="headerlink" title="3.2.5 高级查询"></a>3.2.5 高级查询</h3><ul><li>query filter<br><br>案例:搜索商品名称包含yagao,而且售价大于25的商品<pre><code class="bash">GET /ecommerce/product/_search{&quot;query&quot;: {  &quot;bool&quot;: {    &quot;must&quot;: {      &quot;match&quot;:{        &quot;name&quot;:&quot;yagao&quot;      }    },    &quot;filter&quot;: {      &quot;range&quot;: {        &quot;price&quot;: {          &quot;gt&quot;: 25        }      }    }  }}}</code></pre></li><li>full-text search<br><br>全文检索<pre><code class="bash">GET /ecommerce/product/_search{&quot;query&quot;: {&quot;match&quot;: {  &quot;producer&quot;: &quot;yagao producer&quot;}}}</code></pre></li><li>phrase search<br><br>短语搜索<pre><code class="bash">GET /ecommerce/product/_search{&quot;query&quot;: {&quot;match_phrase&quot;: {  &quot;producer&quot;: &quot;yagao producer&quot;}}}</code></pre><br></li></ul><p><strong>总结:跟全文检索相对应，相反，全文检索会将输入的搜索串拆解开来，去倒排索引里面去一一匹配，只要能匹配上任意一个拆解后的单词，就可以作为结果返回<br>phrase search，要求输入的搜索串，必须在指定的字段文本中，完全包含一模一样的，才可以算匹配，才能作为结果返回</strong></p><ul><li>highlight search<br><br>高亮搜索结果<pre><code class="bash">GET /ecommerce/product/_search{&quot;query&quot;: {&quot;match&quot;: {  &quot;producer&quot;: &quot;producer&quot;}},&quot;highlight&quot;: {&quot;fields&quot;: {&quot;producer&quot;:{}}}}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> es </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker实战训练营</title>
      <link href="/2019/09/27/Docker%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
      <url>/2019/09/27/Docker%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83%E8%90%A5/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="Docker实战训练营"><a href="#Docker实战训练营" class="headerlink" title="Docker实战训练营"></a>Docker实战训练营</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Docker实战训练营是我从工作中提炼的精华内容，也是我在这个博客的这一片正式博客，该篇博客不是一个简单的知识点，我准备写成一个系列，docker实战系列内容。包括docker入门与进阶，未来有可能还是出对应的视频讲解。敬请各位关注。希望大家能够在这边博客中真正的有所收获，并且提升自己。我华夏熊猫还是很乐意帮助大家的。有任何问题，请评论区留言。谢谢。</p><h1 id="Docker实战训练营大纲"><a href="#Docker实战训练营大纲" class="headerlink" title="Docker实战训练营大纲"></a>Docker实战训练营大纲</h1><table>  <tr>    <th width="33.3%">类别</th>    <th width="33.3%">章节</th>    <th width="33.3%">知识点</th>  </tr>  <tr>    <td rowspan="8">docker快速入门</td>    <td>认识docker</td>    <td>      <li>what is docker</li>      <li> why is docker</li>      <li>docker的优点</li>      <li>docker演示</li>    </td>  </tr>  <tr>  <td>docker安装与使用</td>  <td>    <li>下载docker</li>    <li>安装docker</li>    <li>名词解析</li>  </td>  </tr>  <tr>  <td>docker镜像的常用操作</td>  <td>    <li>获取镜像</li>    <li>查看镜像信息</li>    <li>查找镜像</li>    <li>删除镜像</li>    <li>创建镜像</li>    <li>迁出和载入镜像</li>    <li>上传镜像</li>  </td>  </tr>  <tr>  <td>docerk容器的常用操作 </td>  <td>    <li>创建容器</li>    <li>停止容器</li>    <li>进入容器</li>    <li>删除容器</li>    <li>导入和导出容器</li>  </td>  </tr>  <tr>  <td>docerk仓库</td>  <td>    <li>docker hub</li>    <li>创建仓库</li>    <li>使用仓库</li>    <li>仓库管理</li>  </td>  </tr>  <tr>  <td>docerk数据管理</td>  <td>    <li>数据卷</li>    <li>数据卷容器</li>    <li>利用数据卷迁移容器</li>  </td>  </tr>  <tr>  <td>docerk网络</td>  <td>    <li>容器同宿主通信</li>    <li>容器间相互通信</li>  </td>  </tr>  <tr>  <td>docerk之dockerfile</td>  <td>    <li>dockerfile指令集</li>    <li>dockerfile实战训练</li>    <li>利用dockerfile创建镜像</li>  </td>  </tr>  <tr>  <td rowspan="4">docker之持续集成</td>  <td>持续集成概念</td>  <td>    <li>持续集成是什么</li>    <li>为什么持续集成</li>    <li>持续集成与docker</li>  </td>  </tr>  <tr>  <td>git入门</td>  <td>    <li>git简介</li>    <li>git常用命令</li>    <li>git hook(钩子)的配置</li>  </td>  </tr>  <tr>  <td>jenkins入门</td>  <td>    <li>jenkins简介</li>    <li>jenkins的安装</li>    <li>jenkins的简单配置</li>  </td>  </tr>  <tr>  <td>使用docker完成持续集成</td>  <td>    <li>使用docker完成持续集成</li>  </td>  </tr>  <tr>  <td rowspan="4">docker之持续部署</td>  <td>docker compose</td>  <td>    <li>compose简介</li>    <li>compose安装</li>    <li>利用compose进行容器编排</li>  </td>  </tr>  <tr>  <td>docker machine</td>  <td>    <li>machine与虚拟机软件</li>    <li>machine与Iass平台</li>    <li>运行docker machine</li>  </td>  </tr>  <tr>  <td>docker swarm</td>  <td>    <li>swarm 简介</li>    <li>swarm 安装</li>    <li>swarm对请求处理</li>    <li>swarm集群的调度策略</li>    <li>swarm与machine</li>  </td>  </tr>  <tr>  <td>docker监控和日志管理</td>  <td>    <li>搭建监控报警系统</li>    <li>搭建日志管理系统</li>    <li>模拟访问系统</li>    <li>设置监控和报警策略</li>    <li>收集日志并展现</li>  </td>  </tr>  <tr>  <td rowspan="4">docker与大数据</td>  <td>docker集成HDFS</td>  <td>    <li>环境准备</li>    <li>HDFS安装</li>  </td>  </tr>  <tr>  <td>docker集成YARN</td>  <td>    <li>环境准备</li>    <li>YANR安装</li>  </td>  </tr>  <tr>  <td>docker集成Hive</td>  <td>    <li>环境准备</li>    <li>Hive安装</li>  </td>  </tr>  <tr>  <td>docker集成Zookeeper</td>  <td>    <li>环境准备</li>    <li>zookeeper安装</li>  </td>  </tr></table>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu Docker 安装</title>
      <link href="/2019/09/24/Ubuntu%20Docker%20%E5%AE%89%E8%A3%85/"/>
      <url>/2019/09/24/Ubuntu%20Docker%20%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h1><p>Docker要求ubuntu系统的内核版本高于3.10，在进行浏览本页面时，请首先查看你的系统内核版本。如果不符合要求，请升级内核版本，或者更换其他安装方法。通过uname -a查看系统内核版本。</p><pre><code class="shell">huaxiapanda@huaxiapanda:~$ uname -a</code></pre><p><img src="//huaxiapanda.github.io/2019/09/24/Ubuntu Docker 安装/01.png" alt="图1"></p><h1 id="使用脚本安装Docker"><a href="#使用脚本安装Docker" class="headerlink" title="使用脚本安装Docker"></a>使用脚本安装Docker</h1><h2 id="获取最新版本的docker安装包"><a href="#获取最新版本的docker安装包" class="headerlink" title="获取最新版本的docker安装包"></a>获取最新版本的docker安装包</h2><pre><code class="shell">huaxiapanda@huaxiapanda:~$ wget -qO- https://get.docker.com/ | sh</code></pre><p><img src="//huaxiapanda.github.io/2019/09/24/Ubuntu Docker 安装/02.png" alt="图2"><br>安装完成后，会有一个提示：</p><pre><code class="shell">If you would like to use Docker as a non-root user, you should now consider    adding your user to the &quot;docker&quot; group with something like:    sudo usermod -aG docker runoob   Remember that you will have to log out and back in for this to take effect!  </code></pre><p>当要以非root用户可以直接运行docker时，需要执行 sudo usermod -aG docker huaxiapanda 命令，然后重新登陆，否则会报没有权限的错误。会出现Docker daemon socket权限不足：<br><img src="//huaxiapanda.github.io/2019/09/24/Ubuntu Docker 安装/04.png" alt="图3"></p><ul><li>方案1 ：使用sudo获取root权限</li><li>方案2： 添加docker用户组，将当前用户加入docker用户组<pre><code class="shell">huaxiapanda@huaxiapanda:~$ sudo groupadd docker #添加docker用户组groupadd：“docker”组已存在huaxiapanda@huaxiapanda:~$ sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中正在将用户“huaxiapanda”加入到“docker”组中huaxiapanda@huaxiapanda:~$ newgrp docker #更新用户组huaxiapanda@huaxiapanda:~$ docker ps #测试当前用户是否可以正常使用docker命令CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMEShuaxiapanda@huaxiapanda:~$</code></pre><img src="//huaxiapanda.github.io/2019/09/24/Ubuntu Docker 安装/03.png" alt="图4"><h2 id="启动docker后台服务"><a href="#启动docker后台服务" class="headerlink" title="启动docker后台服务"></a>启动docker后台服务</h2><pre><code class="shell"># 启动docker服务huaxiapanda@huaxiapanda:~$ sudo service docker start# 查看docker服务状态huaxiapanda@huaxiapanda:~$ sudo service docker status</code></pre><img src="//huaxiapanda.github.io/2019/09/24/Ubuntu Docker 安装/05.png" alt="图5"><h2 id="测试运行hello-world"><a href="#测试运行hello-world" class="headerlink" title="测试运行hello-world"></a>测试运行hello-world</h2><pre><code class="shell">huaxiapanda@huaxiapanda:~$ docker run hello-world</code></pre><img src="//huaxiapanda.github.io/2019/09/24/Ubuntu Docker 安装/06.png" alt="图6"><br>至此，你就已经把docker在ubuntu系统安装好了！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+GitHub Pages搭建个人博客站点</title>
      <link href="/2019/09/21/Hexo+GitHub%20Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9/"/>
      <url>/2019/09/21/Hexo+GitHub%20Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="使用GitHub-Pages-Hexo搭建个人博客站点"><a href="#使用GitHub-Pages-Hexo搭建个人博客站点" class="headerlink" title="使用GitHub Pages + Hexo搭建个人博客站点"></a>使用GitHub Pages + Hexo搭建个人博客站点</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个程序员都想把自己学习的过程和开发中遇到的问题记录下来，以便给后来人留下来一点东西参考。在市面上有很多已经成熟的写技术博客的网站，比如掘进、知乎、简书、开源中国、CSDN等,这些网站的特点就是，你不需要关心那么多，只需要在上面写文章即可，网站会帮你管理控制。但是，这些网站也有一些不好的地方，样式单一，不可控制，广告繁多。尤其是CSDN这个网站。广告是特别的多，且下载一些东西的时候，限制特别多。CSDN上现在管理也特别混乱，抄袭成篇，文章大多是小白写的，参考性不大。当然不是贬低小白，只是在陈述一种情况！所以，我没有选择在上述网站写自己的技术博客，于是自己就在github上通过GitHub Pages搭建自己的个人博客站点。现在讲搭建的博客一些步骤记录下来，希望能够对未来的你有所帮助，少趟一些坑。把更多的经历放在博客文章上面。也是自己博客的第一篇文章，如有不足，请多关照。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>Git</li><li>NodeJS</li></ul><p><strong>这里默认搭建已经全部安装好了上述环境，不会的自行百度!对于程序员而言，这些不难的！其次我本身使用的深度国产操作系统(国产Linux),其他操作系统操作步骤一样！略有差别</strong></p><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>打开shell终端，输入命令‘npm install -g hexo’，如果提示权限错误,请在命令前面添加sudo,如图所示:<br><img src="//huaxiapanda.github.io/2019/09/21/Hexo+GitHub Pages搭建个人博客站点/one.png" alt="图1"></p><h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><p>在你的电脑创建一个文件夹用来进行初始化博客,我们在这里创建的文件夹是Hexo,然后切换至Hexo文件夹，执行hexo初始化命令hexo init.<br><img src="//huaxiapanda.github.io/2019/09/21/Hexo+GitHub Pages搭建个人博客站点/two.png" alt="图2"><br>初始化之后，hexo的目录结构如下所示<br><img src="//huaxiapanda.github.io/2019/09/21/Hexo+GitHub Pages搭建个人博客站点/three.png" alt="图3"></p><ul><li>public: 这个是存放hexo编译md文件生成的html文件的一个目录。不用关注</li><li>node_modules: 这个是放一些模块代码的地方。不用关注。</li><li>scaffolds: 这个是存放一些模板md文件的地方。</li><li>source: 这是存放我们自己编写的博客文件的地方。主要关注这个地方。</li><li>themes: 这个地方是存放一些主题文件的地方，我们可以讲下载的主题放在这个文件夹下。</li></ul><h3 id="更换一个博客主题"><a href="#更换一个博客主题" class="headerlink" title="更换一个博客主题"></a>更换一个博客主题</h3><p>hexo的默认的主题是landscape,不是很好看，大家可以根据自己的喜欢设置自己喜欢的博客主题，这里我使用的是<a href="https://yelog.org/" target="_blank" rel="noopener">叶落阁</a>的开源三段式主题。在shell窗口中输入命令：</p><pre><code class="shell">git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo</code></pre><p>克隆完成后，会在themes目录下看见3-hexo目录。接下来会使用3-hexo进行演示。<br>获取更多主题请访问hexo主题页面<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题</a></p><h3 id="修改-config-yml对博客进行基础配置"><a href="#修改-config-yml对博客进行基础配置" class="headerlink" title="修改_config.yml对博客进行基础配置"></a>修改_config.yml对博客进行基础配置</h3><p><img src="//huaxiapanda.github.io/2019/09/21/Hexo+GitHub Pages搭建个人博客站点/four.png" alt="图4"><br><img src="//huaxiapanda.github.io/2019/09/21/Hexo+GitHub Pages搭建个人博客站点/five.png" alt="图5"><br>修改之后进行保存。<br><strong>注意，冒号后面一定要有一个空格，否则编译报错</strong></p><h3 id="预览本地博客"><a href="#预览本地博客" class="headerlink" title="预览本地博客"></a>预览本地博客</h3><ul><li>编译项目：hexo g</li><li>运行项目：hexo s</li></ul><p>在浏览器输入：<a href="http://localhost:4000/就可以本地访问博客主页了" target="_blank" rel="noopener">http://localhost:4000/就可以本地访问博客主页了</a></p><h2 id="部署博客到GitHub-Pages"><a href="#部署博客到GitHub-Pages" class="headerlink" title="部署博客到GitHub Pages"></a>部署博客到GitHub Pages</h2><h3 id="创建GitHub账号"><a href="#创建GitHub账号" class="headerlink" title="创建GitHub账号"></a>创建GitHub账号</h3><p>这个就不多说了，每一个程序员应该都有一个这样的账号，即使没有更新过任何代码。到<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>注册即可。</p><h3 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h3><p><img src="//huaxiapanda.github.io/2019/09/21/Hexo+GitHub Pages搭建个人博客站点/six.png" alt="图6"><br><img src="//huaxiapanda.github.io/2019/09/21/Hexo+GitHub Pages搭建个人博客站点/seven.png" alt="图7"><br>仓库创建好之后，复制仓库的地址。</p><h3 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h3><p><img src="//huaxiapanda.github.io/2019/09/21/Hexo+GitHub Pages搭建个人博客站点/eight.png" alt="图8"><br><strong>注意，冒号后面一定要有一个空格，否则编译报错</strong></p><h3 id="发布到GitHub-Pages"><a href="#发布到GitHub-Pages" class="headerlink" title="发布到GitHub Pages"></a>发布到GitHub Pages</h3><p>首先安装自动部署工作，在shell窗口输入命令：</p><pre><code class="shell">npm install hexo-deployer-git --save</code></pre><p>然后输入命令发布博客:</p><pre><code class="shell">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><p>最后在浏览器输入username.github.io即可访问博客。<br>关于3-hexo主图的使用请参照<a href="https://yelog.org/2017/03/23/3-hexo-instruction/" target="_blank" rel="noopener">3-hexo使用说明</a></p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="关于md文件插入本地图片在GitHub-Pages无法显示的问题说明"><a href="#关于md文件插入本地图片在GitHub-Pages无法显示的问题说明" class="headerlink" title="关于md文件插入本地图片在GitHub Pages无法显示的问题说明"></a>关于md文件插入本地图片在GitHub Pages无法显示的问题说明</h3><p> 由于hexo3版本后对很多插件支持有问题，hexo-asset-image插件在处理data.permalink链接时出现路径错误，把年月去掉了，导致最后生成的路径为%d/xxx/xxx需要对其做兼容处理。通过判断当前版本是否等于3的版本做不同的路径分割。因此，这里提供一个已经修复这个bug的插件</p><pre><code class="shell">npm install https://github.com/7ym0n/hexo-asset-image --save</code></pre><p>之后重新编译发布即可。然后刷新浏览器即可！</p><h3 id="使用插件生产rss订阅信息"><a href="#使用插件生产rss订阅信息" class="headerlink" title="使用插件生产rss订阅信息"></a>使用插件生产rss订阅信息</h3><ul><li>hexo博客有一个专门生成RSS xml文件的插件hexo-generator-feed,我们只需要安装这个插件并配置即可。<pre><code class="shell">npm install hexo-generator-feed</code></pre></li><li>启用插件<br>在博客工程的根目录下的_config.xml文件中添加如下内容:<pre><code># Extensions## Plugins: https://hexo.io/plugins/plugins:hexo-generator-feed# feed atomfeed:type: atompath: atom.xmllimit: 20</code></pre><img src="//huaxiapanda.github.io/2019/09/21/Hexo+GitHub Pages搭建个人博客站点/nine.png" alt="图9"><br>之后需要修改themes/3-hexo目录下的_config.xml文件<pre><code>link:theme: color # 链接样式，color: 彩色图标  white: 黑白图标items:  rss: /atom.xml  github: https://github.com/huaxiapanda  email: huaxiapanda@163.com  qq: 805056750  kugou: https://www.kugou.com/  linkedin:  reddit:  jianshu:  zhihu:  oschina:  juejin:</code></pre><img src="//huaxiapanda.github.io/2019/09/21/Hexo+GitHub Pages搭建个人博客站点/ten.png" alt="图10"><br>重新发布,重新刷新浏览器即可.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
